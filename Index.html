<style>
  body, html {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  /* video, .final_canvas { */
  .final_canvas {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
    position: absolute;
    left: 0;
    top: 0;
    transform: rotateY(180deg);
    -webkit-transform: rotateY(180deg);
    -moz-transform: rotateY(180deg);
  }

  #liveView {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .canvas {
    z-index: 1;
    position: relative;
    pointer-events: none;
  }
</style>

<body>
  <video id="webcam" autoplay playsinline></video>
  <canvas class="final_canvas" id="final_canvas"></canvas>

  <script type="module">
    // import {
    //   PoseLandmarker,
    //   FilesetResolver,
    //   DrawingUtils
    // } from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.17";

    async function loadPoseLandmarker() {
      let PoseLandmarker, FilesetResolver, DrawingUtils;

      try {
        ({ PoseLandmarker, FilesetResolver, DrawingUtils } = await import("https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.17"));
        console.log("Task 1: Loaded from Skypack");
      } catch (e) {
        ({ PoseLandmarker, FilesetResolver, DrawingUtils } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.17"));
        console.log("Task 1: Loaded from jsDelivr");
      }

      return { PoseLandmarker, FilesetResolver, DrawingUtils };
    }

    let poseLandmarker = undefined;
    let runningMode = "VIDEO";
    let webcamRunning = true;
    
    loadPoseLandmarker().then(({ PoseLandmarker, FilesetResolver, DrawingUtils }) => {
      // Code that uses PoseLandmarker, FilesetResolver, and DrawingUtils
    const createPoseLandmarker = async () => {

      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.17/wasm"
      );
      poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_heavy/float16/latest/pose_landmarker_heavy.task`,
          delegate: "GPU"
        },
        runningMode: runningMode,
        numPoses: 2,
        minPoseDetectionConfidence: 0.4,
        minPosePresenceConfidence: 0.5,
        minPoseTrackingConfidence: 0.4,
        outputSegmentationMasks: false,
      });
    };
    createPoseLandmarker();
    console.log("PoseLandmarker is loading...");

    const video = document.getElementById("webcam");
    // turn off display of video element
    video.style.display = "none";

    // Create a canvas element to display the final output.
    const finalCanvasElement = document.getElementById("final_canvas");
    const finalCanvasCtx = finalCanvasElement.getContext("2d");
    // finalCanvasElement.style.display = "block";
    const drawingUtils = new DrawingUtils(finalCanvasCtx);
    let result_landmarks = [];
    

    const hasGetUserMedia = () => !!navigator.mediaDevices?.getUserMedia;

    if (hasGetUserMedia()) {
      enableCam();

    } else {
      console.warn("getUserMedia() is not supported by your browser");
    }

    function enableCam(event) {
      const constraints = {
        video: true
      };

      navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
        const videoHeight = stream.getVideoTracks()[0].getSettings().height;
        const videoWidth = stream.getVideoTracks()[0].getSettings().width;
        window.videoHeight = videoHeight;
        window.videoWidth = videoWidth;
        adjustCanvasSize();
        
        video.srcObject = stream;
        video.addEventListener("loadeddata", predictWebcam);
      });
    }

    let lastVideoTime = -1;
    async function predictWebcam() {

      if (runningMode === "IMAGE") {
        runningMode = "VIDEO";
        await poseLandmarker.setOptions({ runningMode: "VIDEO" });
      }
      let startTimeMs = performance.now();

      // Draw the final canvas.
      finalCanvasCtx.save();
      finalCanvasCtx.clearRect(0, 0, finalCanvasElement.width, finalCanvasElement.height);
      finalCanvasCtx.drawImage(video, 0, 0, finalCanvasElement.width, finalCanvasElement.height);

      if (lastVideoTime !== video.currentTime) {
        lastVideoTime = video.currentTime;
        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {

          result_landmarks = result.landmarks;
    
        });
      }
      // Draw the landmarks, if result_landmarks is not empty.
      if (result_landmarks.length == []) {
        finalCanvasCtx.restore();
        return;
      }
      for (const landmark of result_landmarks) {
        drawingUtils.drawLandmarks(landmark, {
          radius: (data) => DrawingUtils.lerp(data.from.z, -0.15, 0.1, 5, 1)
        });
        drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);
      }

      finalCanvasCtx.restore();

      if (webcamRunning === true) {
        window.requestAnimationFrame(predictWebcam);
      }
    };

    function adjustCanvasSize() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      finalCanvasElement.width = width;
      finalCanvasElement.height = height;
    };
    // window.addEventListener('resize', adjustCanvasSize);
  });
  </script>
</body>
